--- a/configure.ac	2013-05-31 21:00:25.000000000 +0900
+++ b/configure.ac	2013-09-05 18:07:17.323457665 +0900
@@ -61,6 +61,20 @@
 )
 
 AC_ARG_ENABLE(
+	[aead-modes],
+	[AS_HELP_STRING([--disable-aead-modes], [disable AEAD crypto modes @<:@default=yes@:>@])],
+	,
+	[enable_aead_modes="yes"]
+)
+
+AC_ARG_ENABLE(
+	[xtra-cipher-modes],
+	[AS_HELP_STRING([--disable-xtra-cipher-modes], [disable xtra cipher modes @<:@default=yes@:>@])],
+	,
+	[enable_xtra_cipher_modes="yes"]
+)
+
+AC_ARG_ENABLE(
 	[ssl],
 	[AS_HELP_STRING([--disable-ssl], [disable SSL support for TLS-based key exchange @<:@default=yes@:>@])],
 	,
@@ -777,6 +791,26 @@
 		[have_openssl_engine="no"; break]
 	)
 
+	have_openssl_aead_modes="yes"
+	AC_CHECK_FUNCS(
+		[ \
+			EVP_aes_256_ccm \
+			EVP_aes_256_gcm \
+		],
+		,
+		[have_openssl_aead_modes="no"; break]
+	)
+
+	have_openssl_xtra_cipher_modes="yes"
+	AC_CHECK_FUNCS(
+		[ \
+			EVP_aes_256_ctr \
+			EVP_aes_256_xts \
+		],
+		,
+		[have_openssl_xtra_cipher_modes="no"; break]
+	)
+
 	CFLAGS="${saved_CFLAGS}"
 	LIBS="${saved_LIBS}"
 fi
@@ -947,6 +981,14 @@
 		CRYPTO_SSL_LIBS="${OPENSSL_SSL_LIBS}"
 		AC_DEFINE([ENABLE_CRYPTO_OPENSSL], [1], [Use OpenSSL library])
 		test "${have_openssl_engine}" = "yes" && AC_DEFINE([HAVE_OPENSSL_ENGINE], [1], [Use crypto library])
+		if test "${enable_aead_modes}" = "yes"; then
+			test "${have_openssl_aead_modes}" = "yes" && AC_DEFINE([HAVE_AEAD_CIPHER_MODES], [1], [Use crypto library])
+			test "${have_openssl_aead_modes}" != "yes" && AC_MSG_ERROR([AEAD modes required but missing])
+		fi
+		if test "${enable_xtra_cipher_modes}" = "yes"; then
+			test "${have_openssl_xtra_cipher_modes}" = "yes" && AC_DEFINE([HAVE_XTRA_CIPHER_MODES], [1], [Use crypto library])
+			test "${have_openssl_xtra_cipher_modes}" != "yes" && AC_MSG_ERROR([Xtra cipher modes required but missing])
+		fi
 		;;
 	polarssl)
 		have_crypto_crypto="${have_polarssl_crypto}"
--- a/src/openvpn/crypto.c	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto.c	2013-09-06 18:51:57.318718005 +0900
@@ -94,16 +94,21 @@
   if (buf->len > 0 && opt->key_ctx_bi)
     {
       struct key_ctx *ctx = &opt->key_ctx_bi->encrypt;
+      unsigned int mode = 0;
 
       /* Do Encrypt from buf -> work */
       if (ctx->cipher)
 	{
 	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
 	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
-	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
+	  int block_size = cipher_ctx_block_size (ctx->cipher);
+	  mode = cipher_ctx_mode (ctx->cipher);
 	  int outlen;
 
-	  if (mode == OPENVPN_MODE_CBC)
+	  if (all_xtra_mode (mode))
+	    ASSERT (opt->flags & CO_USE_IV);	/* IV required */
+
+	  if (mode == OPENVPN_MODE_CBC || all_xtra_mode (mode))
 	    {
 	      CLEAR (iv_buf);
 
@@ -132,7 +137,7 @@
 	      buf_set_write (&b, iv_buf, iv_size);
 	      ASSERT (packet_id_write (&pin, &b, true, false));
 	    }
-	  else /* We only support CBC, CFB, or OFB modes right now */
+	  else /* We only support CBC, CFB, OFB, CTR, XTS or AEAD modes right now */
 	    {
 	      ASSERT (0);
 	    }
@@ -144,14 +149,14 @@
 	  if (opt->flags & CO_USE_IV)
 	    dmsg (D_PACKET_CONTENT, "ENCRYPT IV: %s", format_hex (iv_buf, iv_size, 0, &gc));
 
-	  dmsg (D_PACKET_CONTENT, "ENCRYPT FROM: %s",
-	       format_hex (BPTR (buf), BLEN (buf), 80, &gc));
+	  dmsg (D_PACKET_CONTENT, "ENCRYPT FROM:[%u] %s",
+		BLEN (buf), format_hex (BPTR (buf), BLEN (buf), 90, &gc));
 
 	  /* cipher_ctx was already initialized with key & keylen */
 	  ASSERT (cipher_ctx_reset(ctx->cipher, iv_buf));
 
 	  /* Buffer overflow check */
-	  if (!buf_safe (&work, buf->len + cipher_ctx_block_size(ctx->cipher)))
+	  if (!buf_safe (&work, buf->len + block_size))
 	    {
 	      msg (D_CRYPT_ERRORS, "ENCRYPT: buffer size error, bc=%d bo=%d bl=%d wc=%d wo=%d wl=%d cbs=%d",
 		   buf->capacity,
@@ -160,10 +165,18 @@
 		   work.capacity,
 		   work.offset,
 		   work.len,
-		   cipher_ctx_block_size (ctx->cipher));
+		   block_size);
 	      goto err;
 	    }
 
+#if 0
+	  /* For AEAD ciphers, we need to update with the AAD before ciphertext */
+	  if (aead_mode (mode))
+	    {
+	      rand_bytes (aad, 1);
+	      ASSERT (cipher_ctx_update_aad (ctx->cipher, aad, 1));
+	    }
+#endif
 	  /* Encrypt packet ID, payload */
 	  ASSERT (cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)));
 	  work.len += outlen;
@@ -171,7 +184,13 @@
 	  /* Flush the encryption buffer */
 	  ASSERT(cipher_ctx_final(ctx->cipher, BPTR (&work) + outlen, &outlen));
 	  work.len += outlen;
-	  ASSERT (outlen == iv_size);
+
+	  dmsg (D_PACKET_CONTENT, "ENCRYPT TO:[%u] %s",
+		BLEN (&work), format_hex (BPTR (&work), BLEN (&work), 45, &gc));
+
+	  /* Some cipher modes don't need padding */
+	  if (block_size != 1)
+	    ASSERT (outlen == iv_size);
 
 	  /* prepend the IV to the ciphertext */
 	  if (opt->flags & CO_USE_IV)
@@ -181,8 +200,10 @@
 	      memcpy (output, iv_buf, iv_size);
 	    }
 
-	  dmsg (D_PACKET_CONTENT, "ENCRYPT TO: %s",
-	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));
+#if 0
+	  if (aead_moade (mode))
+	    memcpy (output + iv_size, aad, 1);
+#endif
 	}
       else				/* No Encryption */
 	{
@@ -206,6 +227,16 @@
 	  ASSERT (output);
 	  hmac_ctx_final (ctx->hmac, output);
 	}
+      else if (aead_mode (mode))
+	{
+	  int tag_len = ccm_mode (mode) ? OPENVPN_CCM_TAG_LENGTH : OPENVPN_GCM_TAG_LENGTH;
+	  uint8_t* output = NULL;
+
+	  output = buf_prepend (&work, tag_len);
+	  ASSERT (output);
+	  ASSERT (cipher_ctx_get_tag (ctx->cipher, output, tag_len));
+	  dmsg (D_PACKET_CONTENT, "AEAD TAG: %s", format_hex (output, tag_len, 0, &gc));
+	}
 
       *buf = work;
     }
@@ -275,11 +306,21 @@
 	  const unsigned int mode = cipher_ctx_mode (ctx->cipher);
 	  const int iv_size = cipher_ctx_iv_length (ctx->cipher);
 	  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];
+	  uint8_t tag_buf[OPENVPN_AEAD_TAG_LENGTH]; /* tag of AEAD ciphertext */
+	  int tag_len = ccm_mode (mode) ? OPENVPN_CCM_TAG_LENGTH : OPENVPN_GCM_TAG_LENGTH;
 	  int outlen;
 
 	  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */
 	  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));
 
+	  /* for AEAD ciphers, keep the tag value to feed in later */
+	  if (aead_mode (mode))
+	    {
+	      CLEAR (tag_buf);
+	      memcpy (tag_buf, BPTR (buf), tag_len);
+	      ASSERT (buf_advance (buf, tag_len));
+	    }
+
 	  /* use IV if user requested it */
 	  CLEAR (iv_buf);
 	  if (opt->flags & CO_USE_IV)
@@ -305,27 +346,46 @@
 	  if (!buf_safe (&work, buf->len))
 	    CRYPT_ERROR ("buffer overflow");
 
+	  /* feed in tag and the authenticated data for AEAD mode ciphers */
+	  if (aead_mode (mode))
+	    {
+#if 0
+	      uint8_t aad[OPENVPN_AAD_LENGTH];
+
+	      memcpy (aad, BPTR (buf), 1);
+	      ASSERT (buf_advance (buf, 1));
+#endif
+	      ASSERT (cipher_ctx_set_tag (ctx->cipher, tag_buf, tag_len));
+	   /* ASSERT (cipher_ctx_update_aad (ctx->cipher, aad, 1)); */
+	      dmsg (D_PACKET_CONTENT, "AEAD TAG: %s",
+		    format_hex (tag_buf, tag_len, 0, &gc));
+	    }
+
 	  /* Decrypt packet ID, payload */
 	  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))
 	    CRYPT_ERROR ("cipher update failed");
 	  work.len += outlen;
 
+	  if (ccm_mode (mode))
+	    goto skipfinal;
 	  /* Flush the decryption buffer */
 	  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))
 	    CRYPT_ERROR ("cipher final failed");
 	  work.len += outlen;
+	skipfinal:
 
-	  dmsg (D_PACKET_CONTENT, "DECRYPT TO: %s",
-	       format_hex (BPTR (&work), BLEN (&work), 80, &gc));
+	  dmsg (D_PACKET_CONTENT, "DECRYPT [%u] %s, to:[%u] %s",
+		BLEN (buf), format_hex (BPTR (buf), BLEN (buf), 27, &gc),
+		BLEN (&work), format_hex (BPTR (&work), BLEN (&work), 90, &gc));
 
 	  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */
 	  {
-	    if (mode == OPENVPN_MODE_CBC)
+	    if (mode == OPENVPN_MODE_CBC || all_xtra_mode (mode))
 	      {
 		if (opt->packet_id)
 		  {
 		    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))
-		      CRYPT_ERROR ("error reading CBC packet-id");
+		      CRYPT_ERROR ("error reading packet-id");
 		    have_pin = true;
 		  }
 	      }
@@ -341,7 +401,7 @@
 		  CRYPT_ERROR ("error reading CFB/OFB packet-id");
 		have_pin = true;
 	      }
-	    else /* We only support CBC, CFB, or OFB modes right now */
+	    else /* We only support CBC, CFB, OFB, CTR, XTS or AEAD modes right now */
 	      {
 		ASSERT (0);
 	      }
@@ -404,6 +464,10 @@
 			    (packet_id ? packet_id_size (packet_id_long_form) : 0) +
 			    ((cipher_defined && use_iv) ? cipher_kt_iv_size (kt->cipher) : 0) +
 			    (cipher_defined ? cipher_kt_block_size (kt->cipher) : 0) + /* worst case padding expansion */
+			    ((cipher_defined && aead_mode (cipher_kt_mode (kt->cipher))) ?
+			      (ccm_mode (cipher_kt_mode (kt->cipher)) ?
+				OPENVPN_CCM_TAG_LENGTH : OPENVPN_GCM_TAG_LENGTH) : 0) +
+				/* + AAD length when use it */
 			    kt->hmac_length);
 }
 
@@ -416,6 +480,8 @@
 	       bool authname_defined, int keysize,
 	       bool cfb_ofb_allowed, bool warn)
 {
+  bool aead_cipher = false;
+
   CLEAR (*kt);
   if (ciphername && ciphername_defined)
     {
@@ -427,7 +493,8 @@
       /* check legal cipher mode */
       {
 	const unsigned int mode = cipher_kt_mode (kt->cipher);
-	if (!(mode == OPENVPN_MODE_CBC
+	aead_cipher = aead_mode (mode);
+	if (!(mode == OPENVPN_MODE_CBC || all_xtra_mode (mode)
 #ifdef ALLOW_NON_CBC_CIPHERS
 	      || (cfb_ofb_allowed && (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB))
 #endif
@@ -446,10 +513,14 @@
     }
   if (authname && authname_defined)
     {
-      kt->digest = md_kt_get (authname);
-      kt->hmac_length = md_kt_size (kt->digest);
+      if (aead_cipher) {
+	msg (M_FATAL, "AEAD mode cipher '%s' does not need an HMAC algorithm", ciphername);
+      } else {
+	kt->digest = md_kt_get (authname);
+	kt->hmac_length = md_kt_size (kt->digest);
+      }
     }
-  else
+  else if (!aead_cipher)
     {
       if (warn)
 	msg (M_WARN, "******* WARNING *******: null MAC specified, no authentication will be used");
--- a/src/openvpn/crypto.h	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto.h	2013-09-06 17:07:45.426772020 +0900
@@ -393,6 +393,38 @@
   return key->encrypt.cipher || key->encrypt.hmac || key->decrypt.cipher || key->decrypt.hmac;
 }
 
+static inline bool
+aead_mode (int mode)
+{
+#ifdef HAVE_AEAD_CIPHER_MODES
+  return mode == OPENVPN_MODE_CCM || mode == OPENVPN_MODE_GCM;
+#else
+  return false;
+#endif
+}
+
+static inline bool
+all_xtra_mode (int mode)
+{
+  return false
+#ifdef HAVE_AEAD_CIPHER_MODES
+    || mode == OPENVPN_MODE_CCM || mode == OPENVPN_MODE_GCM
+#endif
+#ifdef HAVE_XTRA_CIPHER_MODES
+    || mode == OPENVPN_MODE_CTR || mode == OPENVPN_MODE_XTS
+#endif
+      ;
+}
+
+static inline bool
+ccm_mode (int mode)
+{
+#ifdef HAVE_AEAD_CIPHER_MODES
+  return mode == OPENVPN_MODE_CCM;
+#else
+  return false;
+#endif
+}
 
 #endif /* ENABLE_CRYPTO */
 #endif /* CRYPTO_H */
--- a/src/openvpn/crypto_backend.h	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto_backend.h	2013-09-05 16:27:45.057260820 +0900
@@ -330,6 +330,37 @@
  */
 int cipher_ctx_final (cipher_ctx_t *ctx, uint8_t *dst, int *dst_len);
 
+/**
+ * Sets the expected message authenticated code (MAC) tag for this cipher.
+ *
+ * @param ctx		The cipher's context
+ * @param tag		The expected MAC tag
+ * @param tag_size	The tag's size, in bytes.
+ */
+int cipher_ctx_set_tag (cipher_ctx_t *ctx, uint8_t* tag, int tag_len);
+
+/**
+ * Gets the expected message authenticated code (MAC) tag for this cipher.
+ *
+ * @param ctx		The cipher's context
+ * @param tag		The expected MAC tag
+ * @param tag_size	The tag's size, in bytes.
+ */
+int cipher_ctx_get_tag (cipher_ctx_t *ctx, uint8_t* tag, int tag_len);
+
+/**
+ * Updates the given cipher context, setting the additional authenticated
+ * data (AAD) used with authenticated encryption with additional data (AEAD)
+ * cipher modes.
+ *
+ * @param ctx 		Cipher's context. May not be NULL.
+ * @param src		Source buffer
+ * @param src_len	Length of the source buffer, in bytes
+ *
+ * @return 		\c 0 on failure, \c 1 on success.
+ */
+int cipher_ctx_update_aad (cipher_ctx_t *ctx, uint8_t *src, int src_len);
+
 /*
  *
  * Generic message digest information functions
--- a/src/openvpn/crypto_openssl.c	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto_openssl.c	2013-09-05 18:12:56.777301892 +0900
@@ -201,6 +201,11 @@
 #endif
   OpenSSL_add_all_algorithms ();
 #endif
+#ifdef HAVE_AEAD_CIPHER_MODES
+  EVP_add_cipher(EVP_aes_128_ccm());
+  EVP_add_cipher(EVP_aes_192_ccm());
+  EVP_add_cipher(EVP_aes_256_ccm());
+#endif
 
   /*
    * If you build the OpenSSL library and OpenVPN with
@@ -316,6 +321,12 @@
 	{
 	  const unsigned int mode = EVP_CIPHER_mode (cipher);
 	  if (mode == EVP_CIPH_CBC_MODE
+#ifdef HAVE_AEAD_CIPHER_MODES
+	      || mode == EVP_CIPH_CCM_MODE || mode == EVP_CIPH_GCM_MODE
+#endif
+#ifdef HAVE_XTRA_CIPHER_MODES
+	      || mode == EVP_CIPH_CTR_MODE || mode == EVP_CIPH_XTS_MODE
+#endif
 #ifdef ALLOW_NON_CBC_CIPHERS
 	      || mode == EVP_CIPH_CFB_MODE || mode == EVP_CIPH_OFB_MODE
 #endif
@@ -608,6 +619,36 @@
   return EVP_CipherFinal (ctx, dst, dst_len);
 }
 
+int
+cipher_ctx_set_tag (EVP_CIPHER_CTX *ctx, uint8_t *tag_buf, int tag_size)
+{
+#ifdef HAVE_AEAD_CIPHER_MODES	/* same as CCM */
+  return EVP_CIPHER_CTX_ctrl (ctx, EVP_CTRL_GCM_SET_TAG, tag_size, tag_buf);
+#else
+  ASSERT (0);
+#endif
+}
+
+int cipher_ctx_get_tag (EVP_CIPHER_CTX *ctx, uint8_t *tag_buf, int tag_size)
+{
+#ifdef HAVE_AEAD_CIPHER_MODES	/* same as CCM */
+  return EVP_CIPHER_CTX_ctrl (ctx, EVP_CTRL_GCM_GET_TAG, tag_size, tag_buf);
+#else
+  ASSERT (0);
+#endif
+}
+
+int
+cipher_ctx_update_aad (EVP_CIPHER_CTX *ctx, uint8_t* src, int src_len)
+{
+#ifdef HAVE_AEAD_CIPHER_MODES
+  int len;
+  return EVP_CipherUpdate_ov (ctx, NULL, &len, src, src_len);
+#else
+  ASSERT (0);
+#endif
+}
+
 
 void
 cipher_des_encrypt_ecb (const unsigned char key[DES_KEY_LENGTH],
--- a/src/openvpn/crypto_openssl.h	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto_openssl.h	2013-09-06 17:23:15.662056599 +0900
@@ -61,6 +61,37 @@
 /** Cipher is in CFB mode */
 #define OPENVPN_MODE_CFB 	EVP_CIPH_CFB_MODE
 
+#ifdef HAVE_AEAD_CIPHER_MODES
+
+/** Cipher is in CCM mode */
+#define OPENVPN_MODE_CCM 	EVP_CIPH_CCM_MODE
+
+/** Cipher is in GCM mode */
+#define OPENVPN_MODE_GCM 	EVP_CIPH_GCM_MODE
+
+#define OPENVPN_AEAD_TAG_LENGTH	EVP_GCM_TLS_TAG_LEN
+#define OPENVPN_AAD_LENGTH	16
+
+#else
+
+#define OPENVPN_AEAD_TAG_LENGTH	0
+#define OPENVPN_AAD_LENGTH	0
+
+#endif /* HAVE_AEAD_CIPHER_MODES */
+
+#define OPENVPN_GCM_TAG_LENGTH	16
+#define OPENVPN_CCM_TAG_LENGTH	12
+
+#ifdef HAVE_XTRA_CIPHER_MODES
+
+/** Cipher is in CTR mode */
+#define OPENVPN_MODE_CTR 	EVP_CIPH_CTR_MODE
+
+/** Cipher is in XTS mode */
+#define OPENVPN_MODE_XTS 	EVP_CIPH_XTS_MODE
+
+#endif /* HAVE_XTRA_CIPHER_MODES */
+
 /** Cipher should encrypt */
 #define OPENVPN_OP_ENCRYPT 	1
 
--- a/src/openvpn/crypto_polarssl.c	2013-05-31 21:00:07.000000000 +0900
+++ b/src/openvpn/crypto_polarssl.c	2013-09-05 15:47:10.516160602 +0900
@@ -493,6 +493,21 @@
   return 0 == retval;
 }
 
+int cipher_ctx_set_tag (cipher_ctx_t *ctx, uint8_t* tag, int tag_len)
+{
+  ASSERT (0);
+}
+
+int cipher_ctx_get_tag (cipher_ctx_t *ctx, uint8_t* tag, int tag_len)
+{
+  ASSERT (0);
+}
+
+int cipher_ctx_update_aad (cipher_ctx_t *ctx, uint8_t *src, int src_len)
+{
+  ASSERT (0);
+}
+
 void
 cipher_des_encrypt_ecb (const unsigned char key[DES_KEY_LENGTH],
     unsigned char *src,
